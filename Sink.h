/*
	Sinks. Collect traffic generated by the mobile nodes.
*/

#ifndef _SINK_
#define _SINK_

#include "packet.h"


// Define macros for colors
#define RESET   "\033[0m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"


#define DEBUG_PRINTS 0 // to set up fancy output packet per packet
#if DEBUG_PRINTS
    #define PRINTF_COLOR(color, format, ...) printf(color format RESET, ##__VA_ARGS__)
#else
    #define PRINTF_COLOR(color, format, ...) (void)0 // do nothing
#endif




#define SUBSAMPLE_TIME 50000

component Sink : public TypeII
{
	public:
		// Connections
		inport void in(data_packet &packet);

	public:
		void Setup();
		void Start();
		void Stop();

	public:
		double system_time;
		double received_packets;
		double av_L; // average packet length



		// DBG 
		double queue_time_total ; 
		double service_time_total ; 
		double total_qs_time; 

		int subsample_timer; 

        struct csv_sink_t {
			std::vector <double> timestamp; 
            std::vector <double> L_ampdu; 
            std::vector <int>    destination; 
            std::vector <int>    source; 
            std::vector <double> T_s; 
            std::vector <double> T_q;  
        }sinkcsv; 
};

void Sink :: Setup()
{

};

void Sink :: Start()
{
	system_time = 0;
	received_packets = 0;
	subsample_timer = 0; 

	queue_time_total = 0; 
	service_time_total = 0; 
	total_qs_time = 0. ; 
};

void Sink :: Stop()
{	
	// printf("\n[SINK]\n");
	// printf("test Average System Time (Queueing + Transmission) = %.7f\n",system_time/received_packets);
	// printf("Avg Received throughput = %.7f bits/s\n", av_L/SimTime());

	// printf("[SINK STOP DBG]  Queue Time: %.6f, Service Time: %.6f, (Queue + service) Time: %.6f\n",
        //    queue_time_total/received_packets, service_time_total/received_packets, total_qs_time/received_packets);
};


void Sink :: update_stats_AMPDU(data_packet &ampdu_packet){

    // double queue_delay = ?? 
    double service_delay = data_packet.T

    double STA_ID = id; 

    double AMPDU_L = data_packet.L; 

    double T_s = data_packet.T; 
    double T_q = data_packet.T_q; 

    sinkcsv.L_ampdu.push_back(AMPDU_L);
    sinkcsv.T_s.push_back(T_s);
    sinkcsv.T_q.push_back(T_q);
    sinkcsv.destination.push_back(data_packet.destination);
    sinkcsv.source.push_back(data_packet.source);

    // PRINTF_COLOR(RED, "")

} 



// struct data_packet
// {
// 	double L_data; // Packet (data) length
// 	double L_header; // Header Length
// 	double L; // Total length
// 	int AMPDU_size; // Number of aggregated packets

// 	// Statistics
// 	double sent_time; // Time at which the packet is generated from the source
// 	double scheduled_time; // Time at which the packet is selected for transmission	
// 	double queueing_service_delay;

// 	double num_seq;	
// 	int destination; // id of the destination station
// 	int source; // id of the traffic source

// 	int source_app;
// 	int destination_app;
	
// 	// To be used by the channel
// 	double T; // Transmission time, include DIFS, SIFS, etc.
// 	double T_c; //

// 	// For the XR server and client communication
// 	int first_video_frame_packet;
// 	int last_video_frame_packet;
// 	int num_packet_in_the_frame;
// 	double frame_generation_time;
// 	int NumPacketsPerFrame;
// 	double TimeSentAtTheServer;
// 	double TimeReceivedAtTheClient;
// 	double video_frame_seq;
// 	double frames_received;


// 	bool feedback;
// 	bool rtt;

// 	double m_owdg;
// 	double threshold_gamma; 


// 	bool sliding_rx_frame_loss; 
// 	double frame_numseq; 
	
// 	struct Kalman_t{
// 				double OW_Delay;
// 				double K_gain;
// 				double m_current; 
// 				double m_prev; 
// 				double residual_z;
// 			}Kalman_p; 

	
// 	double packets_received;
// }; 




void Sink :: in(data_packet &ampdu_packet) // AMPDU version
{	
	PRINTF_COLOR( MAGENTA, "[DBG SINK]  ----AMPDU received at %.5f\n", SimTime());
    

    



	// for (const auto& packet : ampdu_packet.mpdu_packets) { // iterate through each received packet! 

	// 	system_time += SimTime() - packet.STA_send_time;
	// 	av_L += packet.L;
	// 	received_packets++;

	// 	double total_time = SimTime() - packet.queue_arrival_time;
	// 	double queue_time = packet.queue_departure_time - packet.queue_arrival_time;
	// 	double service_time = packet.service_end_time - packet.queue_departure_time; 
	// 	PRINTF_COLOR( MAGENTA, "[DBG SINK]\t\t\tPacket %.0Lf at sink. T = %.4f ms, T_s = %.4f ms, T_q = %.4f ms\n", packet.packet_ID, total_time * 1000, service_time * 1000, queue_time * 1000);

	// 	queue_time_total += queue_time;
	// 	service_time_total += service_time;
	// 	total_qs_time += total_time; 
    // }

};


#endif
